---
title: "Project 1"
author: Keshav Ramesh & Calista Harris
format: pdf
editor: visual
editor_options: 
  chunk_output_type: console
---

Load require packages
```{r, message=FALSE, warning=FALSE}
library(tidyverse)
```

# Data Processing

## Question 1: Reading in Data 

```{r}
edu01a <- read_csv("EDU01a.csv", show_col_types = FALSE) |>
  select(
    area_name = Area_name, #rename Area_name
    STCOU,
    ends_with("D") #select all columns ending in "D"
  )

#display the first 5 rows
edu01a |> 
  slice(1:5)
```

## Question 2: Pivot Data

```{r}
edu_long <- edu01a %>%
  pivot_longer(
    cols = ends_with("D"), 
    names_to = "surveyID_full", #store original column names (ex. "EST1234D")
    values_to = "enrollment"
  )

#display the first 5 rows
head(edu_long, 5)
```

## Question 3: Extracting the year 

```{r}
long_updated <- edu_long %>%
  mutate(
    #extract the 2-digit year from the 8th and 9th characters of surveyID_full 
    surveyID_year = substr(surveyID_full, 8, 9)
    ) %>%
  mutate(
    #convert the 2-digit year into a 4-digit year (assuming all are 1900s)
    year = as.numeric(paste0("19", surveyID_year))
  ) %>%
  mutate(
    #extract the survey ID (first 7 characters of surveyID_full)
    surveyID = substr(surveyID_full, 1, 7)
  ) %>%
  #remove the temporary intermediate column
  select(-surveyID_year)

#display the first 5 rows
head(long_updated, 5)
```

## Question 4: Identifying County Data

```{r}
#identify county rows: ", XX" (where XX is a two-letter state abbreviation)
county_indices <- grep(pattern = ", \\w\\w", long_updated$area_name)

#create county tibble and assign custom classes
county_tibble <- long_updated[county_indices, ]
class(county_tibble) <- c("county", class(county_tibble))

#create non-county tibble and assign custom classes
state_tibble <- long_updated[-county_indices, ]
class(state_tibble) <- c("state", class(state_tibble))

#display the first 10 rows for both data sets
head(county_tibble, 10)
head(state_tibble, 10)
```

## Question 5: Add `state` Variable to the County Tibble

```{r}
county_tibble <- county_tibble |> 
  mutate(
    #use nchar to get the last 2 characters of area_name
    state = substr(area_name, nchar(area_name) - 1, nchar(area_name))
  )

#display the first 5 rows
county_tibble |> 
  slice(1:5)
```

## Question 6: Add `division` Variable to the Non-county Tibble

```{r}
state_tibble <- state_tibble %>%
  mutate(
    state = substr(area_name, nchar(area_name) - 1, nchar(area_name)),
    division = case_when(
      state %in% c("CT", "ME", "MA", "NH", "RI", "VT") ~ "New England",
      state %in% c("NJ", "NY", "PA") ~ "Mid-Atlantic",
      
      state %in% c("IL", "IN", "MI", "OH", "WI") ~ "East North Central",
      state %in% c("IA", "KS", "MN", "MO", "NE", 
                   "ND", "SD") ~ "West North Central",
      
      state %in% c("DE", "DC", "FL", "GA", "MD", "NC", 
                   "SC", "VA", "WV") ~ "South Atlantic",
      state %in% c("AL", "KY", "MS", "TN") ~ "East South Central",
      state %in% c("AR", "LA", "OK", "TX") ~ "West South Central",
      
      state %in% c("AZ", "CO", "ID", "MT", "NV", 
                   "NM", "UT", "WY") ~ "Mountain",
      state %in% c("AK", "CA", "HI", "OR", "WA") ~ "Pacific",
      
      TRUE ~ "ERROR"  #return error for non-states like "UNITED STATES"
    )
  ) |> 
  #remove the temporary intermediate column
  select(-state)

#display the first 5 rows
state_tibble |> 
  slice(1:5)
```

# Requirements: Repeating Process with 2nd Component of Data Set

## Create a Function for Steps 1 and 2

```{r}
#read in the data set
edu01b <- read_csv("EDU01b.csv", show_col_types = FALSE)

select_pivot <- function(data, column = "enrollment") {
  data |> 
    #step 1
    select(
      area_name = Area_name,
      STCOU,
      ends_with("D")
    ) |> 
    #step 2
    pivot_longer(
      cols = ends_with("D"),
      names_to = "surveyID_full",
      values_to = column
    )
}

#test the function to see if it works correctly 
edu_long <- select_pivot(edu01b) 

#display the first 5 rows
edu_long |> 
  slice(1:5)
```

## Create a Function for Taking Output of Step 2 and Step 3

```{r}
extract_year_id <- function(data) {
  data |> 
    mutate(
      surveyID_year = substr(surveyID_full, 8, 9),
      year = as.numeric(paste0("19", surveyID_year)),
      surveyID = substr(surveyID_full, 1, 7)
    ) |> 
  select(-surveyID_year)
}

#test the function to see if it works correctly 
long_updated <- extract_year_id(edu_long) 

#display the first 5 rows
long_updated |> 
  slice(1:5)
```

## Create a Function for Step 5

```{r}
#only to be used for the county tibble
extract_state <- function(county_tbl){
   county_tbl |> 
    mutate(
      state = substr(area_name, nchar(area_name) - 1, nchar(area_name))
  )
}

#test the function to see if it works correctly 

#first repeat steps 4 to get county_tibble
county_indices <- grep(pattern = ", \\w\\w", long_updated$area_name)
county_tibble <- long_updated[county_indices, ]
class(county_tibble) <- c("county", class(county_tibble))

#use the function 
county_tibble <- extract_state(county_tibble) 

#display the first 5 rows
county_tibble |> 
  slice(1:5)
```

## Create a Function for Step 6

```{r}
#only to be used for the non-county (state) tibble
assign_division <- function(state_tbl){
  state_tbl |> 
    mutate(
    state = substr(area_name, nchar(area_name) - 1, nchar(area_name)),
    division = case_when(
      state %in% c("CT", "ME", "MA", "NH", "RI", "VT") ~ "New England",
      state %in% c("NJ", "NY", "PA") ~ "Mid-Atlantic",
      
      state %in% c("IL", "IN", "MI", "OH", "WI") ~ "East North Central",
      state %in% c("IA", "KS", "MN", "MO", "NE", 
                   "ND", "SD") ~ "West North Central",
      
      state %in% c("DE", "DC", "FL", "GA", "MD", "NC", 
                   "SC", "VA", "WV") ~ "South Atlantic",
      state %in% c("AL", "KY", "MS", "TN") ~ "East South Central",
      state %in% c("AR", "LA", "OK", "TX") ~ "West South Central",
      
      state %in% c("AZ", "CO", "ID", "MT", "NV", 
                   "NM", "UT", "WY") ~ "Mountain",
      state %in% c("AK", "CA", "HI", "OR", "WA") ~ "Pacific",
      
      TRUE ~ "ERROR"  
    )
  ) |> 
  select(-state)
}

#test the function to see if it works correctly 

#first repeat steps 4 to get state_tibble
county_indices <- grep(pattern = ", \\w\\w", long_updated$area_name)
state_tibble <- long_updated[-county_indices, ]
class(state_tibble) <- c("state", class(state_tibble))

#use the function 
state_tibble <- assign_division(state_tibble) 

#display the first 5 rows
state_tibble |> 
  slice(1:5)
```

## Create a Function Returning Two Final Tibbles

```{r}
identify_locations <- function(data) {
  #step 4
  county_indices <- grep(pattern = ", \\w\\w", long_updated$area_name)

  county_tibble <- long_updated[county_indices, ]
  class(county_tibble) <- c("county", class(county_tibble))
  
  state_tibble <- long_updated[-county_indices, ]
  class(state_tibble) <- c("state", class(state_tibble))
  
  #step 5 using the functions create
  county_tibble <- extract_state(county_tibble)
  state_tibble  <- assign_division(state_tibble)
  
  #return both tibbles as a list
  return(list(county = county_tibble, state = state_tibble))
}

#test the function to see if it works correctly 

#applied the functions created above first
read_edu <- select_pivot(edu01b)
long_updated <- extract_year_id(read_edu)
edu01b_split <- identify_locations(long_updated)

#display the individual outputs
edu01b_split$county |> 
  slice(1:5)
edu01b_split$state |> 
  slice(1:5)
```















